# Раздел 2. Основные концепции языков программирования (Java)

## *Содержание*

1. Фундаментальные типы данных. Целочисленные типы, представление отрицательных чисел. Числа с плавающей точкой, их двоичное представление. Символьный и логический типы. Явные и неявные приведения типов. Перегрузка функций.  
2. Классы. Объекты. Поля, методы. Конструкторы. Ключевое слово this. Статические члены класса. Модификаторы доступа, инкапсуляция. Внутренние классы, локальные классы, их особенности и примеры.  
3. Наследование. Преобразования типов между родителем и наследником. Переопределение методов у наследника. Абстрактные классы. Интерфейсы. Принцип подстановки Лисков.  
4. Исключения. Иерархия исключений. Проверяемые и непроверяемые исключения. Конструкция try with resources.  
5. Стандартные коллекции: ArrayList, LinkedList, HashMap, TreeMap, LinkedHashMap. Их основные методы и внутреннее устройство.  
6. Лямбда-функции. Элементы функционального программирования. Захват окружения. Ссылки на методы.  
7. Optional. Stream API. Промежуточные и терминальные операции. Коллекторы, комбинации коллекторов.  
8. Аннотации. Объявление и применение аннотаций. Мета-аннотации `@Target`, `@Retention`. Параметры аннотаций.  
9. Основы многопоточности. Потоки (threads). Создание и завершение потоков. Проблема race condition. Мьютексы и их использование.
10. Spring Framework. Чем отличается управление объектами через \`new\` от управления через Inversion of Control. Какие способы внедрения зависимостей поддерживаются. Что такое Spring Bean и какие аннотации используются для создания бинов. Скоупы бинов.  
11. Spring MVC. Отличие `@Controller` от `@RestController`. Маппинг HTTP-запросов (`@GetMapping`, `@PostMapping` и т.д). Обработка исключений с помощью `@ControllerAdvice`. Интерcепторы. Валидация объектов (`@NotBlank`, `@Email` и т.д).  
12. OpenAPI. Использование OpenAPI в документирование REST API. Инструменты для генерации документации OpenAPI в Spring.  
13. Hibernate. Как Hibernate связан с JPA. Как работают `@OneToMany`, `@ManyToOne`, `@ManyToMany`? В чем разница между `EAGER` и `LAZY` загрузкой? Жизненный цикл сущности в Hibernate. Транзакции в Spring (`@Transactional`), параметры `isolation` и`propagation`.  
14. Spring Security. Настройка аутентификации через базу данных. Реализация JWT-аутентификации в Spring Security.  
15. Синхронное и асинхронное взаимодействие в распределенной среде, их преимущества и недостатки. Реализации инструментов (HTTP, брокеры сообщений и т.д). 

___
## 1. Фундаментальные типы данных. Целочисленные типы, представление отрицательных чисел. Числа с плавающей точкой, их двоичное представление. Символьный и логический типы. Явные и неявные приведения типов. Перегрузка функций. 

Все значения в Java делятся на два типа: примитивы и объекты. К примитивам относятся следующие типы данных:
- `byte` - 8-битовое целое число со знаком. Может принимать значение от $-128$ до $127$.
- `short` - 16-битовое целое число со знаком. Может принимать значение от $-32768$ до $32767$.
- `int` - 32-битовое целое число со знаком. Может принимать значение от $-2^{31}$ до $2^{31} - 1$.
- `long` - 64-битовое целое число. Число со знаком может принимать значение от $-2^{63}$ до $2^{63} - 1$.
- `float` - 32-битовое число с плавающей запятой.
- `double` - 64-битовое число с плавающей запятой.
- `boolean` - логический тип данных, может иметь только 2 значения, `true` или `false`.
- `char` - один символ в формате Unicode.

Любые другие значения являются объектами.

В Java переменные хранятся следующим образом:
1. Локальные переменные, такие как примитивы и ссылки на объекты, создаются в стеке.
2. Объекты – в куче (heap).

Java – язык _pass by value_, то есть значения переменной копируются при передаче в функцию. В случаем примитивов копируется непосредственно значение, для объектов – копия ссылки.

#### Целочисленные типы

`byte` (1 байт), `short` (2 байт), `int` (4 байт) и `long` (8 байт).

`byte` в основном используется для уменьшения расхода памяти при хранении данных в массивах (например, хранение данных, полученных по сети в некотором буфере, который будет реализован в виде массива байт). В арифметических операциях он не используется. Связано это с реализацией Java Virtual Machine (JVM). Так как большинство систем 32 или 64 разрядные, то `byte` и `short` при вычислениях будут приведены к 32-битному `int`:

```Java
byte a = 1;
byte b = 2; 
byte result = a + b;
```
```
error: incompatible types: possible lossy conversion from int to byte
```

`long` позволяет считать большие числа. Часто используется при работе со временем (можно встретить как тип для аргумента millis при работе с потоками). Для обозначения того, что число это long после числа ставят литерал L: `long n = 10L; \\ можно 10l`

"Минус" для отрицательных чисел берётся из старшего бита, т.е. $10000000$ это запись $-128$, а $01111111$ – запись $127$.

#### Числа с плавающей точкой

`float` и `double`, литералы `1.1F` и `1.1` (или `1.1D`) соответственно. Они реализуют международный стандарт IEEE 754: числовые типы данных с плавающей точкой состоят из трёх частей: *знака* $s$, *мантиссы* $M$ и *порядка* $q$: $(-1)^s \cdot M \cdot 2^q$.

- **float**: 4 байта, точность ~7 десятичных знаков. Хранится как: 1 бит на знак, 8 на порядок, 23 на мантиссу.
- **double**: 8 байт, точность ~15–17 десятичных знаков. Хранится как: 1 бит на знак, 11 на порядок, 52 на мантиссу.

Особенности:
- Можно также использовать научную нотация для литералов: `1.1e-3`
- Из-за такой формы хранения существует два нуля: $0.0$ и $-0.0$
- Специальные значения: $Infinity$ и $-Infinity$ (деление на ноль полож./отриц. числа соответственно), а также $NaN$ (Not a Number, ноль на ноль, sqrt из отрицательного числа, сложение + и - бесконечностей и т.п.).

#### Символьный и логический типы.

`boolean` может хранить только два значения: `true` (истина) или `false` (ложь). Размер неизвестен и зависит от JVM (Например может быть: 8 бит в массивах `boolean[]` на куче, а на стеке он хранится как 32-битный int).

`char` занимает в памяти 16 бит и описывает символ. В Java для `char` используется кодировка Unicode. Символ можно задать в соответствии с двумя таблицами: таблица Unicode символов и таблица ASCII символов. Для литералов используются одинарные кавычки.

```
char symbolF = 'f';
symbolF = 102;
symbolF = '\u0066';
```

Также является числом и поддерживает математические операции (в которых кастуется к `int`).

#### Явные и неявные преобразования типов

Каждый примитивный тип в Java имеет фиксированный размер, что определяет его диапазон и точность. При взаимодействии типов с разной разрядностью возникают ситуации несоответствия, которые Java разрешает либо автоматически, либо требует вмешательства программиста (явное приведение).

Автоматические преобразования (неявные, расширение) выполняются по следующим цепочкам:

![](images/java/cast.png)
Стрелками на рисунке показано, какие преобразования типов могут выполняться автоматически. Пунктирными стрелками показаны автоматические преобразования с потерей точности.

Автоматически без каких-либо проблем производятся расширяющие преобразования (widening) – они расширяют представление объекта в памяти. Например:

```Java
byte b = 4;
int i = b;
```

Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типа с меньшей разрядностью. Это следующие цепочки преобразований: `int -> float`, `long -> float` и `long -> double`. Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.

```Java
int a = 2147483647;
float b = a; // int -> float
System.out.println(b);  // 2.1474836E9
```

Внутри арифметических выражений происходит *продвижение типов*. Java всегда подтягивает аргументы к "старшему" типу перед вычислением:
- Если есть хоть один `double`, всё станет `double`.
- Иначе, если есть `float`, всё станет `float`.
- Иначе, если есть `long`, всё станет `long`
- `byte`, `short` и `char` изначально преобразуются в `int`

Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью:

```Java
long a = 4l;
int b = (int) a;
```

При применении явных преобразований мы можем столкнуться с потерей данных. Например, в следующем коде у нас не возникнет никаких проблем:

```Java
int a = 5;
byte b = (byte) a;
```

Число 5 вполне укладывается в диапазон значений типа `byte`, поэтому после преобразования переменная b будет равна 5. Однако в другом примере:

```Java
int a = 258
byte b = (byte) a;
```

результатом будет число 2. В данном случае число 258 вне диапазона для типа byte (от -128 до 127), поэтому произойдет усечение значения. Число a, которое равно 258, в двоичном системе будет равно `00000000 00000000 00000001 00000010`. Значения типа byte занимают в памяти только 8 бит. Поэтому двоичное представление числа int усекается до 8 правых разрядов, то есть `00000010`, что в десятичной системе дает число 2.

Другие подобные случаи:
```Java
int a = 130;
byte b = (byte) a;
System.out.println(b);
    
a = 128;
b = (byte) a;
System.out.println(b);
    
a = 256;
b = (byte) a;
System.out.println(b);
```
```
-126
-128
0
```

#### Перегрузка функций

Перегрузка – это возможность определить в одном классе несколько методов с одинаковым именем, но разными входными параметрами. Это проявление статического полиморфизма (того, что разрешается во время компиляции).

```Java
public class Program{
    public static void main(String[] args){
        Calcualtor calc = new Calcualtor();
        System.out.println(calc.sum(2, 3));
        System.out.println(calc.sum(2.3, 3.2));
        System.out.println(calc.sum(2.3, 3.2, 4));
    }
}

class Calcualtor {
    int sum(int x, int y){
        return x + y;
    }
    
    double sum(double x, double y){
        return x + y;
    }

    double sum(double x, double y, long z){
        return x + y + z;
    }
}
```

 На перегрузку методов влияют количество и типы параметров. Однако различие в типе возвращаемого значения для перегрузки не имеют никакого значения. Например, в следующем случае методы sum различаются по типу возвращаемого значения:

```Java
public class Program{
    public static void main(String[] args){
        Calcualtor calc = new Calcualtor();
        System.out.println(calc.sum(2, 3));
        System.out.println(calc.sum(2, 3));
    }
}

class Calcualtor {
    int sum(int x, int y){
        return x + y;
    }
    
    // error: method sum(int,int) is already defined in class Calcualtor
    double sum(int x, int y){
        return x + y;
    }
}
```

___
## 2. Классы. Объекты. Поля, методы. Конструкторы. Ключевое слово this. Статические члены класса. Модификаторы доступа, инкапсуляция. Внутренние классы, локальные классы, их особенности и примеры.

[TODO]

___
## 3. Наследование. Преобразования типов между родителем и наследником. Переопределение методов у наследника. Абстрактные классы. Интерфейсы. Принцип подстановки Лисков.

[TODO]

___
## 4. Исключения. Иерархия исключений. Проверяемые и непроверяемые исключения. Конструкция try with resources. 

[TODO]

___
## 5. Стандартные коллекции: ArrayList, LinkedList, HashMap, TreeMap, LinkedHashMap. Их основные методы и внутреннее устройство.

[TODO]

___
## 6. Лямбда-функции. Элементы функционального программирования. Захват окружения. Ссылки на методы.

[TODO]

___
## 7. Optional. Stream API. Промежуточные и терминальные операции. Коллекторы, комбинации коллекторов.

[TODO]

___
## 8. Аннотации. Объявление и применение аннотаций. Мета-аннотации `@Target`, `@Retention`. Параметры аннотаций.

[TODO]

___
## 9. Основы многопоточности. Потоки (threads). Создание и завершение потоков. Проблема race condition. Мьютексы и их использование.

[TODO]

___
## 10. Spring Framework. Чем отличается управление объектами через `new` от управления через Inversion of Control. Какие способы внедрения зависимостей поддерживаются. Что такое Spring Bean и какие аннотации используются для создания бинов. Скоупы бинов.

[TODO]

___
## 11. Spring MVC. Отличие `@Controller` от `@RestController`. Маппинг HTTP-запросов (`@GetMapping`, `@PostMapping` и т.д). Обработка исключений с помощью `@ControllerAdvice`. Интерcепторы. Валидация объектов (`@NotBlank`, `@Email` и т.д).

[TODO]

___
## 12. OpenAPI. Использование OpenAPI в документирование REST API. Инструменты для генерации документации OpenAPI в Spring.

[TODO]

___
## 13. Hibernate. Как Hibernate связан с JPA. Как работают `@OneToMany`, `@ManyToOne`, `@ManyToMany`? В чем разница между `EAGER` и `LAZY` загрузкой? Жизненный цикл сущности в Hibernate. Транзакции в Spring (`@Transactional`), параметры `isolation` и`propagation`.

[TODO]

___
## 14. Spring Security. Настройка аутентификации через базу данных. Реализация JWT-аутентификации в Spring Security.

[TODO]

___
## 15. Синхронное и асинхронное взаимодействие в распределенной среде, их преимущества и недостатки. Реализации инструментов (HTTP, брокеры сообщений и т.д). 

[TODO]