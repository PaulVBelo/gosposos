# Раздел 2. Основные концепции языков программирования (Java)

## *Содержание*

1. Фундаментальные типы данных. Целочисленные типы, представление отрицательных чисел. Числа с плавающей точкой, их двоичное представление. Символьный и логический типы. Явные и неявные приведения типов. Перегрузка функций.  
2. Классы. Объекты. Поля, методы. Конструкторы. Ключевое слово this. Статические члены класса. Модификаторы доступа, инкапсуляция. Внутренние классы, локальные классы, их особенности и примеры.  
3. Наследование. Преобразования типов между родителем и наследником. Переопределение методов у наследника. Абстрактные классы. Интерфейсы. Принцип подстановки Лисков.  
4. Исключения. Иерархия исключений. Проверяемые и непроверяемые исключения. Конструкция try with resources.  
5. Стандартные коллекции: ArrayList, LinkedList, HashMap, TreeMap, LinkedHashMap. Их основные методы и внутреннее устройство.  
6. Лямбда-функции. Элементы функционального программирования. Захват окружения. Ссылки на методы.  
7. Optional. Stream API. Промежуточные и терминальные операции. Коллекторы, комбинации коллекторов.  
8. Аннотации. Объявление и применение аннотаций. Мета-аннотации `@Target`, `@Retention`. Параметры аннотаций.  
9. Основы многопоточности. Потоки (threads). Создание и завершение потоков. Проблема race condition. Мьютексы и их использование.
10. Spring Framework. Чем отличается управление объектами через \`new\` от управления через Inversion of Control. Какие способы внедрения зависимостей поддерживаются. Что такое Spring Bean и какие аннотации используются для создания бинов. Скоупы бинов.  
11. Spring MVC. Отличие `@Controller` от `@RestController`. Маппинг HTTP-запросов (`@GetMapping`, `@PostMapping` и т.д). Обработка исключений с помощью `@ControllerAdvice`. Интерcепторы. Валидация объектов (`@NotBlank`, `@Email` и т.д).  
12. OpenAPI. Использование OpenAPI в документирование REST API. Инструменты для генерации документации OpenAPI в Spring.  
13. Hibernate. Как Hibernate связан с JPA. Как работают `@OneToMany`, `@ManyToOne`, `@ManyToMany`? В чем разница между `EAGER` и `LAZY` загрузкой? Жизненный цикл сущности в Hibernate. Транзакции в Spring (`@Transactional`), параметры `isolation` и`propagation`.  
14. Spring Security. Настройка аутентификации через базу данных. Реализация JWT-аутентификации в Spring Security.  
15. Синхронное и асинхронное взаимодействие в распределенной среде, их преимущества и недостатки. Реализации инструментов (HTTP, брокеры сообщений и т.д). 

___
## 1. Фундаментальные типы данных. Целочисленные типы, представление отрицательных чисел. Числа с плавающей точкой, их двоичное представление. Символьный и логический типы. Явные и неявные приведения типов. Перегрузка функций. 

Все значения в Java делятся на два типа: примитивы и объекты. К примитивам относятся следующие типы данных:
- `byte` - 8-битовое целое число со знаком. Может принимать значение от $-128$ до $127$.
- `short` - 16-битовое целое число со знаком. Может принимать значение от $-32768$ до $32767$.
- `int` - 32-битовое целое число со знаком. Может принимать значение от $-2^{31}$ до $2^{31} - 1$.
- `long` - 64-битовое целое число. Число со знаком может принимать значение от $-2^{63}$ до $2^{63} - 1$.
- `float` - 32-битовое число с плавающей запятой.
- `double` - 64-битовое число с плавающей запятой.
- `boolean` - логический тип данных, может иметь только 2 значения, `true` или `false`.
- `char` - один символ в формате Unicode.

Любые другие значения являются объектами.

В Java переменные хранятся следующим образом:
1. Локальные переменные, такие как примитивы и ссылки на объекты, создаются в стеке.
2. Объекты – в куче (heap).

Java – язык _pass by value_, то есть значения переменной копируются при передаче в функцию. В случаем примитивов копируется непосредственно значение, для объектов – копия ссылки.

#### Целочисленные типы

`byte` (1 байт), `short` (2 байт), `int` (4 байт) и `long` (8 байт).

`byte` в основном используется для уменьшения расхода памяти при хранении данных в массивах (например, хранение данных, полученных по сети в некотором буфере, который будет реализован в виде массива байт). В арифметических операциях он не используется. Связано это с реализацией Java Virtual Machine (JVM). Так как большинство систем 32 или 64 разрядные, то `byte` и `short` при вычислениях будут приведены к 32-битному `int`:

```Java
byte a = 1;
byte b = 2; 
byte result = a + b;
```
```
error: incompatible types: possible lossy conversion from int to byte
```

`long` позволяет считать большие числа. Часто используется при работе со временем (можно встретить как тип для аргумента millis при работе с потоками). Для обозначения того, что число это long после числа ставят литерал L: `long n = 10L; \\ можно 10l`

"Минус" для отрицательных чисел берётся из старшего бита, т.е. $10000000$ это запись $-128$, а $01111111$ – запись $127$.

#### Числа с плавающей точкой

`float` и `double`, литералы `1.1F` и `1.1` (или `1.1D`) соответственно. Они реализуют международный стандарт IEEE 754: числовые типы данных с плавающей точкой состоят из трёх частей: *знака* $s$, *мантиссы* $M$ и *порядка* $q$: $(-1)^s \cdot M \cdot 2^q$.

- **float**: 4 байта, точность ~7 десятичных знаков. Хранится как: 1 бит на знак, 8 на порядок, 23 на мантиссу.
- **double**: 8 байт, точность ~15–17 десятичных знаков. Хранится как: 1 бит на знак, 11 на порядок, 52 на мантиссу.

Особенности:
- Можно также использовать научную нотация для литералов: `1.1e-3`
- Из-за такой формы хранения существует два нуля: $0.0$ и $-0.0$
- Специальные значения: $Infinity$ и $-Infinity$ (деление на ноль полож./отриц. числа соответственно), а также $NaN$ (Not a Number, ноль на ноль, sqrt из отрицательного числа, сложение + и - бесконечностей и т.п.).

#### Символьный и логический типы.

`boolean` может хранить только два значения: `true` (истина) или `false` (ложь). Размер неизвестен и зависит от JVM (Например может быть: 8 бит в массивах `boolean[]` на куче, а на стеке он хранится как 32-битный int).

`char` занимает в памяти 16 бит и описывает символ. В Java для `char` используется кодировка Unicode. Символ можно задать в соответствии с двумя таблицами: таблица Unicode символов и таблица ASCII символов. Для литералов используются одинарные кавычки.

```
char symbolF = 'f';
symbolF = 102;
symbolF = '\u0066';
```

Также является числом и поддерживает математические операции (в которых кастуется к `int`).

#### Явные и неявные преобразования типов

Каждый примитивный тип в Java имеет фиксированный размер, что определяет его диапазон и точность. При взаимодействии типов с разной разрядностью возникают ситуации несоответствия, которые Java разрешает либо автоматически, либо требует вмешательства программиста (явное приведение).

Автоматические преобразования (неявные, расширение) выполняются по следующим цепочкам:

![](images/java/cast.png)
Стрелками на рисунке показано, какие преобразования типов могут выполняться автоматически. Пунктирными стрелками показаны автоматические преобразования с потерей точности.

Автоматически без каких-либо проблем производятся расширяющие преобразования (widening) – они расширяют представление объекта в памяти. Например:

```Java
byte b = 4;
int i = b;
```

Некоторые преобразования могут производиться автоматически между типами данных одинаковой разрядности или даже от типа данных с большей разрядностью к типа с меньшей разрядностью. Это следующие цепочки преобразований: `int -> float`, `long -> float` и `long -> double`. Они производятся без ошибок, но при преобразовании мы можем столкнуться с потерей информации.

```Java
int a = 2147483647;
float b = a; // int -> float
System.out.println(b);  // 2.1474836E9
```

Внутри арифметических выражений происходит *продвижение типов*. Java всегда подтягивает аргументы к "старшему" типу перед вычислением:
- Если есть хоть один `double`, всё станет `double`.
- Иначе, если есть `float`, всё станет `float`.
- Иначе, если есть `long`, всё станет `long`
- `byte`, `short` и `char` изначально преобразуются в `int`

Во всех остальных преобразованиях примитивных типов явным образом применяется операция преобразования типов. Обычно это сужающие преобразования (narrowing) от типа с большей разрядностью к типу с меньшей разрядностью:

```Java
long a = 4l;
int b = (int) a;
```

При применении явных преобразований мы можем столкнуться с потерей данных. Например, в следующем коде у нас не возникнет никаких проблем:

```Java
int a = 5;
byte b = (byte) a;
```

Число 5 вполне укладывается в диапазон значений типа `byte`, поэтому после преобразования переменная b будет равна 5. Однако в другом примере:

```Java
int a = 258
byte b = (byte) a;
```

результатом будет число 2. В данном случае число 258 вне диапазона для типа byte (от -128 до 127), поэтому произойдет усечение значения. Число a, которое равно 258, в двоичном системе будет равно `00000000 00000000 00000001 00000010`. Значения типа byte занимают в памяти только 8 бит. Поэтому двоичное представление числа int усекается до 8 правых разрядов, то есть `00000010`, что в десятичной системе дает число 2.

Другие подобные случаи:
```Java
int a = 130;
byte b = (byte) a;
System.out.println(b);
    
a = 128;
b = (byte) a;
System.out.println(b);
    
a = 256;
b = (byte) a;
System.out.println(b);
```
```
-126
-128
0
```

#### Перегрузка функций

Перегрузка – это возможность определить в одном классе несколько методов с одинаковым именем, но разными входными параметрами. Это проявление статического полиморфизма (того, что разрешается во время компиляции).

```Java
public class Program {
    public static void main(String[] args) {
        Calcualtor calc = new Calcualtor();
        System.out.println(calc.sum(2, 3));
        System.out.println(calc.sum(2.3, 3.2));
        System.out.println(calc.sum(2.3, 3.2, 4));
    }
}

class Calcualtor {
    int sum(int x, int y){
        return x + y;
    }
    
    double sum(double x, double y){
        return x + y;
    }

    double sum(double x, double y, long z){
        return x + y + z;
    }
}
```

 На перегрузку методов влияют количество и типы параметров. Однако различие в типе возвращаемого значения для перегрузки не имеют никакого значения. Например, в следующем случае методы sum различаются по типу возвращаемого значения:

```Java
public class Program{
    public static void main(String[] args){
        Calcualtor calc = new Calcualtor();
        System.out.println(calc.sum(2, 3));
        System.out.println(calc.sum(2, 3));
    }
}

class Calcualtor {
    int sum(int x, int y){
        return x + y;
    }
    
    // error: method sum(int,int) is already defined in class Calcualtor
    double sum(int x, int y){
        return x + y;
    }
}
```

___
## 2. Классы. Объекты. Поля, методы. Конструкторы. Ключевое слово this. Статические члены класса. Модификаторы доступа, инкапсуляция. Внутренние классы, локальные классы, их особенности и примеры.

Java является объектно-ориентированным языком, поэтому такие понятия как "*класс*" и "объект" играют в нем ключевую роль. Любую программу на Java можно представить как набор взаимодействующих между собой объектов. Шаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса.

Класс определяется с помощью ключевого слова `сlass`, после которого идет название класса:

```Java
class MyAwesomeClass {
	\\todo
}
```

Объект создается с помощью оператора `new`. В этот момент на куче выделяется память.

```Java
MyAwesomeClass mac = new MyAwesomeClass();
```

Любой объект может обладать двумя основными характеристиками: состояние - некоторые данные, которые хранит объект, и поведение - действия, которые может совершать объект. Для хранения состояния объекта в классе применяются поля (переменные класса), поведение определяется методами:

```Java
class Person{
	String name;
	int age;

	void print(){
		System.out.printf("Name: %s \tAge: %d\n", name, age);
	}
}
```

Доступ к ним вне класса получаем через точку:

```
объект.полеКласса
объект.методКласса(параметры метода)
```

#### Конструкторы

Конструктор – это специальная функция, которая строит объект на основе переданных атрибутов. Если вы явно не добавляете никаких конструкторов, то Java все равно создаст для класса конструктор без аргументов. Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. Для переменных числовых типов это число 0, а для типа String и классов – это значение `null`.

Если необходимо, чтобы при создании объекта производилась какая-то логика, например, чтобы поля класса получали какие-то определенные значения, то можно определить в классе свои конструкторы. При этом если в классе определяются свои конструкторы, то этот класс лишается конструктора по умолчанию.

```Java
class Graph {
	private List<Integer>[] adjList;
	
	public Graph(int V) {
		adjList = new ArrayList<Integer>[V];
		
		for (int i = 0; i < V; i++) {
			adjList[i] = new ArrayList<Integer>();
		}
	}
}
```

#### Ключевое слово `this`

Ключевое слово `this` представляет ссылку на текущий экземпляр (объект) класса. Через это ключевое слово мы можем обращаться к переменным и методам объекта, а также вызывать его конструкторы:

```Java
class Person {
	private String name;
	
	public Person(String name) {
		this.name = name;
	}
	
	public Person() {
		this.Person("Nameless");
	}
}
```

#### Статические члены класса

Кроме обычных полей, методов, свойств классы и структуры могут иметь статические поля и методы. Для обращения к ним необязательно создавать объект класса.

Пример: класс `Math` (`java.lang.Math`):

```Java
double x = 5.3;
double y = Math.exp(- x*x / 2);
```

Для объявления статических переменных, констант, методов и инициализаторов перед их объявлением указывается ключевое слово `static`. (Статические инициализаторы предназначены для инициализации статических переменных, либо для выполнения таких действий, которые выполняются при создании самого первого объекта)


```Java
class Person{
    int age;        // обычное поле
    static int retirementAge;  // статическое поле

    static { // статический инициализатор
        retirementAge = 65;
    }

    Person(int age){
        this.age = age;
        System.out.println("Constructor");
    }

    static void checkAge(Person p) { // статический метод
        if (p.age >= retirementAge) {
	        System.out.println("Уже на пенсии");
        } else {
	        System.out.printf("До пенсии осталось %d лет.\n", retirementAge - p.age);
        }
    }
}
```

Следует учитывать, что статические методы могут обращаться только к статическим членам класса. Обращаться к нестатическим методам и полям этого же класса внутри статического метода мы не можем. Поэтому, например, чтобы вызвать в методе main другие методы, которые определены в одном классе с методом main, они также должны иметь модификатор `static`.

#### Модификаторы доступа, инкапсуляция

*Инкапсуляция* – это объединение данных и поведения в одну единицу кода (пакет/модуль/класс и т.д.) и сокрытие деталей реализации (в нашем случае реализации полей и методов) от пользователей объекта. Конкретный объект, являющийся экземпляром класса, будет иметь определённые значения своих полей. Набор этих значений представляет собой текущее состояние объекта. При каждом вызове метода объекта его состояние может измениться.

Все компоненты класса в языке Java имеют модификаторы доступа. Модификаторы доступа управляют видимостью классов, методов и переменных, тем самым определяя, как к компонентам класса можно получить доступ из других частей программы. Они управляют тем, откуда можно получить доступ к конкретному классу, методу или переменной.

В Java используются следующие модификаторы доступа:
- **`public`**: публичный, общедоступный класс или компонент класса. Поля и методы, объявленные с модификатором public, видны другим классам из текущего пакета и из внешних пакетов, вообще в любом месте программы. В исходном файле может быть только один класс с модификатором public, но количество классов с другими модификаторами (или без них) может быть любым. Если в файле есть класс с модификатором public, то имя файла должно совпадать с именем этого класса.
- **`private`**: закрытый класс или компонент класса, противоположность модификатору public. Закрытый класс или компонент класса доступен только из кода в том же классе.
- **`protected`**: такой класс или компонент класса доступен из любого места в текущем классе или пакете или в производных классах, даже если они находятся в других пакетах
- **Модификатор по умолчанию**. Отсутствие модификатора у поля или метода класса предполагает применение к нему модификатора по умолчанию. Такие поля или методы видны всем классам в текущем пакете.

![](images/java/modifiers.png)
#### Внутренние классы, локальные классы, их особенности и примеры

**Внутренние классы** – это классы, объявленные внутри другого класса. Они имеют доступ ко всем полям и методам внешнего класса, включая `private`. Не могут содержать статические поля/методы. Чаще всего используются, когда логика тесно связана с внешним классом и не имеет смысла существовать отдельно. Для создания объекта внутреннего класса требуется объект внешнего класса.

**Локальные классы** объявляются внутри метода, конструктора или блока кода. Они применяются, когда класс нужен только в пределах одного метода. Локальные классы имеют доступ к полям внешнего класса и к локальным переменным метода (если после инициализации их значение не изменяется). Не могут иметь модификаторов доступа.

```Java
public class Outer {
    private int outerField = 10;

    class Inner {
        void printOuterField() {
            System.out.println("Outer field: " + outerField);
        }
    }

    void methodWithLocalClass() {
        int localVariable = 5;

        class Local {
            void printSum() {
                System.out.println("Sum: " + (outerField + localVariable));
            }
        }

        Local local = new Local();
        local.printSum();
    }

    public static void main(String[] args) {
        Outer outer = new Outer();
        Inner inner = outer.new Inner();
        inner.printOuterField();
        outer.methodWithLocalClass();
    }
}
```

___
## 3. Наследование. Преобразования типов между родителем и наследником. Переопределение методов у наследника. Абстрактные классы. Интерфейсы. Принцип подстановки Лисков.

Одним из ключевых аспектов объектно-ориентированного программирования является наследование. С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого.

Чтобы унаследовать один класс от другого, надо использовать после имени класса-наследника ключевое слово extends, после которого идет имя базового класса:

```Java
class Base {}

class Derived extends Base {}
```

Мы можем использовать функционал базового класса, обращаясь к объекту производного класса. Также можно в производном классе расширить функционал базового – добавить свои поля и методы.

Если в базовом классе определены конструкторы, то в конструкторе производного классы необходимо вызвать один из конструкторов базового класса с помощью ключевого слова super, в который передаются значения для параметров конструкторов.

```Java
class Base {
	String strField;
	
	public Base(String str) {
		this.strField = str;
	}
}

class Derived extends Base {
	int intField;
	
	public Derived(String str, int num) {
		super(str);
		this.intField = num;
	}
}
```

Стоит отметить, что при определении конструктора в производном классе до версии Java 25 вызов конструктора суперкласса должны был выполняться ДО всех остальных инструкций.

#### Преобразования типов между родителем и наследником

Преобразование от наследника к родителю происходит автоматически, так как дочерний класс всегда содержит в себе всё то, что есть в родительском.

```Java
Base base = new Derived("six", 7);
```

После такого преобразования будут доступны только методы, которые определённые в базовом классе.

Преобразование от родителя к наследнику не происходит автоматически, так как компилятор не может гарантировать, что в переменной родительского типа реально лежит нужный подкласс. Это придётся делать явно, причём если попытаться привести родителя к тому наследнику, которым он на самом деле не является, возникает `ClassCastException`.

```Java
Animal animal = new Cat();

Cat cat = (Cat) animal;
cat.meow(); // Теперь есть доступ к методам, определённым в Cat

Dog dog = (Dog) animal; // ClassCastException
```

Для безопасной проверки в Java есть оператор `isinstanceof`:

```Java
if (animal instanceof Cat) {
    Cat cat = (Cat) animal;
    cat.meow();
}

// С Java 14 есть PatternMatching и можно делать так:
if (animal instanceof Cat cat) {
    cat.meow();
}
```

#### Переопределение методов у наследника

Производный класс может переопределять методы, которые унаследованы от базового класса. При переопределении метода производный класс определяет метод с той же сигнатурой (имя, аргументы) и аннотацией `@Override` (аннотация не обязательна):

```Java
class DayPhaser extends Phaser {
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        if (registeredParties == 0) {
            return true;
        }

        System.out.println("\n===== ДЕНЬ " + (phase + 2) + " =====");
        return false;
    }
}
```

При переопределении метода он должен иметь уровень доступа не меньше, чем уровень доступа в базовом класса. Например, если в базовом классе метод имеет модификатор public, то и в производном классе метод должен иметь модификатор public.

С помощью ключевого слова super мы также можем обратиться к реализации базового класса:

```Java
class DayPhaser extends Phaser {
    @Override
    protected boolean onAdvance(int phase, int registeredParties) {
        System.out.println("\n===== ДЕНЬ " + (phase + 2) + " =====");
        return super.onAdvance(phase, registedParties);
    }
}
```

Можно запретить переопределение методов или наследоваться от класса с помощью ключевого слова `final`:

```Java
final class FinalClassExample {}

class Base {
	int intField = 3;
	
	final void foo() {
		System.out.println(" -_- ");
	}
}
```

#### Абстрактные классы

Кроме обычных классов в Java есть абстрактные классы. Абстрактный класс похож на обычный класс. В абстрактном классе также можно определить поля и методы, но в то же время нельзя создать объект или экземпляр абстрактного класса. Абстрактные классы призваны предоставлять базовый функционал для классов-наследников. А производные классы уже реализуют этот функционал. При определении абстрактных классов используется ключевое слово `abstract`:

```Java
abstract class имяКласса {
	// Что-то написать сюды
}
```

Наряду с абстрактными классами в языке Java есть абстрактные методы. Такие методы также предваряются модификатором `abstract`, но при этом не имеют тела – не выполняют никаких конкретных действий:

```Java
abstract void foo(int a);
```

Производный класс обязан переопределить и реализовать все абстрактные методы, которые имеются в базовом абстрактном классе. Также следует учитывать, что если класс имеет хотя бы один абстрактный метод, то данный класс должен быть определен как абстрактный (и производные абстрактные классы не обязаны реализовывать все абстрактные методы).

Чтобы не писать ещё банальный пример, вот мой абстрактный класс альпиниста из задачи про шерпов. Базовые правила симуляции и порядок действий определяются моделью задачи, однако стратегию для перекладывания еды нужно в каждом наследнике написать свою (это можно было сделать лучше, но даже в таком виде, это показательный пример):

```Java
abstract class HeightBoundClimber extends Thread {
    public static final int DAYS_TO_SUMMIT = 8;
    public static final int BACKPACK_SIZE = 4;

    public static final AtomicBoolean someoneDied = new AtomicBoolean(false);

    protected static DayPhaser phaser;
    protected static SharedEnvironment env;

    protected int height = 0;
    protected int backpack = BACKPACK_SIZE;
    protected boolean ascending = true;

    protected final int maxHeight;

    protected HeightBoundClimber(String name, int maxHeight) {
        super(name);
        this.maxHeight = maxHeight;
        phaser.register();
    }

    @Override
    public final void run() {
        try {
            while (true) {
                pickFood();

                if (!eat()) break;

                move();

                dropFood();

                phaser.arriveAndAwaitAdvance();

                if (isFinished()) break;
            }
        } finally {
            phaser.arriveAndDeregister();
        }
    }

    protected abstract void pickFood();
    protected abstract void dropFood();

    protected boolean eat() {
        if (backpack == 0) {
            someoneDied.set(true);
            System.out.println(getName() + " погиб в горах (нет еды)");
            return false;
        }
        backpack--;
        return true;
    }

    protected void move() {
        if (ascending) height++;
        else height--;
    }

    protected boolean isFinished() {
        if (!ascending && height == 0) {
            System.out.println(getName() + " вернулся домой.");
            return true;
        }
        return false;
    }
}
```

#### Интерфейсы

Механизм наследования очень удобен, но он имеет свои ограничения. В частности, в Java нет множественного наследования (от классов).

Подобную проблему частично позволяют решить интерфейсы. Интерфейсы определяют "контракт" т.е. множество методов (по умолчанию, `public abstract`), не имеющих конкретной реализации, которые затем реализуют классы, применяющие эти интерфейсы. И один класс может применить множество интерфейсов.

Чтобы определить интерфейс, используется ключевое слово `interface`.

```Java
interface Animal {
	public void makeSound();
}
```

Чтобы указать, что класс реализует интерфейс, после названия класса указывается ключевое слово `implements`, после которого идет название интерфейса:

```Java
class Cat implements Animal {
	@Override
	public void makeSound() {
		System.out.println("Meow");
	}
}
```

Интерфейсы в языке Java также могут иметь методы по умолчанию (default methods) – методы с реализацией по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Метод по умолчанию – это обычный метод без модификаторов (формально имеет модификатор `public`), который помечается ключевым словом `default`:

```Java
interface Animal {
	public void makeSound();
	default void info() {
		System.out.println("Is animal.");
	}
}
```

#### Принцип подстановки Лисков

Тут будет частично цитироваться книга "Чистая Архитектура" Роберта Мартина. Рекомендую прочитать 9-ую главу из неё.

> В 1988 году Барбара Лисков написала следующие строки с формулировкой определения подтипов:
> 	*Если для каждого объекта o1 типа S существует какой-то объект o2 типа T, что для всех программ P, определённых в типах T, поведение P не изменяется при подстановке o1 вместо o2, то S является подтипом T.*

Проще говоря: если код зависим от интерфейса, то подстановка любой его реализации не должна ломать код.

Пример архитектуры, соблюдающей этот принцип:

![](images/java/lsp.png)

Есть интерфейс License. В нём определён метод calcFee(), который вызывается приложением Billing. Существует два "подтипа" класса License: PersonalLicense и BusinessLicense. Они реализуют разные алгоритмы расчёта лицензионных отчислений. Оба подтипа могут служить заменой для типа License.

___
## 4. Исключения. Иерархия исключений. Проверяемые и непроверяемые исключения. Конструкция try with resources. 

[TODO]

___
## 5. Стандартные коллекции: ArrayList, LinkedList, HashMap, TreeMap, LinkedHashMap. Их основные методы и внутреннее устройство.

[TODO]

___
## 6. Лямбда-функции. Элементы функционального программирования. Захват окружения. Ссылки на методы.

[TODO]

___
## 7. Optional. Stream API. Промежуточные и терминальные операции. Коллекторы, комбинации коллекторов.

[TODO]

___
## 8. Аннотации. Объявление и применение аннотаций. Мета-аннотации `@Target`, `@Retention`. Параметры аннотаций.

[TODO]

___
## 9. Основы многопоточности. Потоки (threads). Создание и завершение потоков. Проблема race condition. Мьютексы и их использование.

[TODO]

___
## 10. Spring Framework. Чем отличается управление объектами через `new` от управления через Inversion of Control. Какие способы внедрения зависимостей поддерживаются. Что такое Spring Bean и какие аннотации используются для создания бинов. Скоупы бинов.

[TODO]

___
## 11. Spring MVC. Отличие `@Controller` от `@RestController`. Маппинг HTTP-запросов (`@GetMapping`, `@PostMapping` и т.д). Обработка исключений с помощью `@ControllerAdvice`. Интерcепторы. Валидация объектов (`@NotBlank`, `@Email` и т.д).

[TODO]

___
## 12. OpenAPI. Использование OpenAPI в документирование REST API. Инструменты для генерации документации OpenAPI в Spring.

[TODO]

___
## 13. Hibernate. Как Hibernate связан с JPA. Как работают `@OneToMany`, `@ManyToOne`, `@ManyToMany`? В чем разница между `EAGER` и `LAZY` загрузкой? Жизненный цикл сущности в Hibernate. Транзакции в Spring (`@Transactional`), параметры `isolation` и`propagation`.

[TODO]

___
## 14. Spring Security. Настройка аутентификации через базу данных. Реализация JWT-аутентификации в Spring Security.

[TODO]

___
## 15. Синхронное и асинхронное взаимодействие в распределенной среде, их преимущества и недостатки. Реализации инструментов (HTTP, брокеры сообщений и т.д). 

[TODO]