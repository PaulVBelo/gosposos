# Раздел 1. Алгоритмы и структуры данных

## *Содержание*

1. Сортировка слиянием (mergesort). Определение числа инверсий в перестановке за O(n log n).  
2. Быстрая сортировка (quicksort). Поиск k-й порядковой статистики за линейное в среднем время.  
3. Двоичная куча. Пирамидальная сортировка. Построение кучи за линейное время.  
4. Хеш-таблицы. Методы разрешения коллизий: метод цепочек, открытая адресация. Универсальное семейство хеш-функций.  
5. Амортизированная сложность. Динамический массив и оценка сложности его операций.  
6. Динамическое программирование: одномерное, двумерное.  
7. Самобалансирующиеся деревья поиска (рассказать любое на выбор). Реализация и оценка сложности операций вставки, удаления, поиска.  
8. Графы. Представление графов в памяти. Обход в ширину. Обход в глубину. Топологическая сортировка.  
9. Задача поиска кратчайших путей в графе. Алгоритм Дейкстры. Алгоритм Форда–Беллмана.  
10. Задача построения минимального остовного дерева. Алгоритм Крускала. Алгоритм Прима.  
11. Задача о максимальном потоке в графе. Теорема Форда–Фалкерсона. Алгоритм Эдмондса–Карпа.  
12. Дерево отрезков. Ограничения на поддерживаемую операцию. Запросы модификации на отрезке.  
13. Быстрое преобразование Фурье. Применение для умножения длинных чисел и многочленов.  
14. Нахождение обратного элемента по модулю. Быстрое возведение в степень.   
15. Задача поиска подстроки в строке. Алгоритм Рабина–Карпа. Алгоритм Кнута–Морриса–Пратта.  
16. Бор. Алгоритм Ахо–Корасик.

______
## 1. Сортировка слиянием (mergesort). Определение числа инверсий в перестановке за O(n log n).

[TODO]

__________

## 2. Быстрая сортировка (quicksort). Поиск k-й порядковой статистики за линейное в среднем время.

[TODO]

___________
## 3. Двоичная куча. Пирамидальная сортировка. Построение кучи за линейное время.

[TODO]

__________
## 4. Хеш-таблицы. Методы разрешения коллизий: метод цепочек, открытая адресация. Универсальное семейство хеш-функций.

[TODO]

________
## 5. Амортизированная сложность. Динамический массив и оценка сложности его операций.

[TODO]

___________
## 6. Динамическое программирование: одномерное, двумерное.

[TODO]

__________
## 7. Самобалансирующиеся деревья поиска (рассказать любое на выбор). Реализация и оценка сложности операций вставки, удаления, поиска.

[TODO]

________
## 8. Графы. Представление графов в памяти. Обход в ширину. Обход в глубину. Топологическая сортировка.

***def*** *Граф* – пара $G=(V, E)$, где $V$ – множество вершин, $E \subseteq V \times V$ – мультимножество рёбер.

Рёбра в памяти представляются парой вершин, в неориентированных графах при наличии ребра $(u, v)$ также есть и ребро $(v, u)$.

Есть следующие способы хранения графа:
- **Матрица смежности** – двумерный массив $G$ размера $|V| \times |V|$, где $G[u][v] = I[(u, v) \in E]$, т.е. бинарная матрица, хранящая на $u$-ой строке $v$-ом столбце наличие ребра $u \to v$
- **Список смежности** – массив $G$, где $G[u]$ – список всех соседей вершины $u$.

Сравнение по сложности операций:

| Операции                       | Список Смежности                   | Матрица Смежности    |
| ------------------------------ | ---------------------------------- | -------------------- |
| $(u, v) \in E$ ?               | $O(deg(u))$                        | $O(1)$               |
| $E' = E \backslash \{(u, v)\}$ | $O(deg(u))$                        | $O(1)$               |
| Получить список соседей        | $O(1)$                             | $O(\vert V \vert)$   |
| Потребляемая память            | $O(\vert V \vert + \vert E \vert)$ | $O(\vert V \vert^2)$ |
### Обходы
#### Depth-First Search

***def*** *DFS* (depth first seach) – обход в глубину, т.е. обход графа, в котором вершины посещаются как только обнаружены.
Псевдокод:
```java
private static void dfs(ArrayList<Integer>[] graph, int v, int visited) {
	visited[v] = true;
	
	for (int u: gragh[v]) {
		if (!visited[u]) {
			dfs(graph, u, visited);
		}
	}
	
	// Вот здесь выход из вершины (см. топсорт)
}
```
Чёт в таком духе. Без рекурсии пишется со стеком.

#### Breadth-First Search

***def*** *BFS* (breadth-first search) – обход в ширину, т.е. обход графа, в котором сначала посещаются соседи начальной вершины, затем их соседи и т.д.

*Алгоритм:*
- Заведём очередь вершин в неё положим стартовую $s$
- Пока очередь не пустая:
  1. Извлечём вершину $v$ из начала очереди, пометим $v$ как посещённую.
  2. Добавим все смежные не посещённые вершины в очередь.

*Псевдокод:*
```kotlin
private static void bfs(ArrayList<Integer>[] graph, int s) {
	bool[] visited = new bool[];
	ArrayDeque<Integer> queue = new ArrayDeque<Integer>();
	
	queue.add(s)
	while (queue.peek() != null) {
		int v = queue.pop();
		visited[v] = true;
		
		for (int u: graph[v]) {
			if (!visited[u]) {
				queue.add(u);
			}
		}
	}
}
```

#### Topsort

Рассмотрим ориентированный граф, присвоим каждой вершине номер. 

***def*** Перестановка $\sigma$ называется *топологической сортировкой*, если $\forall (u, v)\in E \hookrightarrow \sigma(u) < \sigma(v)$

![](images/algo/topsort.png)
Топологическая сортировка существует только в ацикличном орграфе (т.к. отношение "<" ациклично).

*Алгоритм построения:*
1. Запустим DFS на всём графе. В момент выхода DFS из вершины будем добавлять её в конец массива.
2. Развернём полученный массив. Он содержит перестановку, являющуюся корректным топсортом:
	   В DFS, если вершина $u$ достигается из $v$, то $u$ будет обработана раньше $v$ (раньше выйдет из стека), поэтому сортировка вершин в порядке убывания времён выхода является топологической сортировкой.

_____
## 9. Задача поиска кратчайших путей в графе. Алгоритм Дейкстры. Алгоритм Форда–Беллмана.

[TODO]

___
## 10. Задача построения минимального остовного дерева. Алгоритм Крускала. Алгоритм Прима.

[TODO]

___
## 11. Задача о максимальном потоке в графе. Теорема Форда–Фалкерсона. Алгоритм Эдмондса–Карпа.

[TODO]

___
## 12. Дерево отрезков. Ограничения на поддерживаемую операцию. Запросы модификации на отрезке.

[TODO]

___
## 13. Быстрое преобразование Фурье. Применение для умножения длинных чисел и многочленов.

[TODO]

___
## 14. Нахождение обратного элемента по модулю. Быстрое возведение в степень.

[TODO]

___
## 15. Задача поиска подстроки в строке. Алгоритм Рабина–Карпа. Алгоритм Кнута–Морриса–Пратта.

[TODO]

___
## 16. Бор. Алгоритм Ахо–Корасик.

[TODO]