# Раздел 1. Алгоритмы и структуры данных

## *Содержание*

1. Сортировка слиянием (mergesort). Определение числа инверсий в перестановке за O(n log n).  
2. Быстрая сортировка (quicksort). Поиск k-й порядковой статистики за линейное в среднем время.  
3. Двоичная куча. Пирамидальная сортировка. Построение кучи за линейное время.  
4. Хеш-таблицы. Методы разрешения коллизий: метод цепочек, открытая адресация. Универсальное семейство хеш-функций.  
5. Амортизированная сложность. Динамический массив и оценка сложности его операций.  
6. Динамическое программирование: одномерное, двумерное.  
7. Самобалансирующиеся деревья поиска (рассказать любое на выбор). Реализация и оценка сложности операций вставки, удаления, поиска.  
8. Графы. Представление графов в памяти. Обход в ширину. Обход в глубину. Топологическая сортировка.  
9. Задача поиска кратчайших путей в графе. Алгоритм Дейкстры. Алгоритм Форда–Беллмана.  
10. Задача построения минимального остовного дерева. Алгоритм Крускала. Алгоритм Прима.  
11. Задача о максимальном потоке в графе. Теорема Форда–Фалкерсона. Алгоритм Эдмондса–Карпа.  
12. Дерево отрезков. Ограничения на поддерживаемую операцию. Запросы модификации на отрезке.  
13. Быстрое преобразование Фурье. Применение для умножения длинных чисел и многочленов.  
14. Нахождение обратного элемента по модулю. Быстрое возведение в степень.   
15. Задача поиска подстроки в строке. Алгоритм Рабина–Карпа. Алгоритм Кнута–Морриса–Пратта.  
16. Бор. Алгоритм Ахо–Корасик.

______
## 1. Сортировка слиянием (mergesort). Определение числа инверсий в перестановке за O(n log n).

[TODO]

__________

## 2. Быстрая сортировка (quicksort). Поиск k-й порядковой статистики за линейное в среднем время.

[TODO]

___________
## 3. Двоичная куча. Пирамидальная сортировка. Построение кучи за линейное время.

[TODO]

__________
## 4. Хеш-таблицы. Методы разрешения коллизий: метод цепочек, открытая адресация. Универсальное семейство хеш-функций.

[TODO]

________
## 5. Амортизированная сложность. Динамический массив и оценка сложности его операций.

[TODO]

___________
## 6. Динамическое программирование: одномерное, двумерное.

[TODO]

__________
## 7. Самобалансирующиеся деревья поиска (рассказать любое на выбор). Реализация и оценка сложности операций вставки, удаления, поиска.

[TODO]

________
## 8. Графы. Представление графов в памяти. Обход в ширину. Обход в глубину. Топологическая сортировка.

***def*** *Граф* – пара $G=(V, E)$, где $V$ – множество вершин, $E \subseteq V \times V$ – мультимножество рёбер.

Рёбра в памяти представляются парой вершин, в неориентированных графах при наличии ребра $(u, v)$ также есть и ребро $(v, u)$.

Есть следующие способы хранения графа:
- **Матрица смежности** – двумерный массив $G$ размера $|V| \times |V|$, где $G[u][v] = I[(u, v) \in E]$, т.е. бинарная матрица, хранящая на $u$-ой строке $v$-ом столбце наличие ребра $u \to v$
- **Список смежности** – массив $G$, где $G[u]$ – список всех соседей вершины $u$.

Сравнение по сложности операций:

| Операции                       | Список Смежности                   | Матрица Смежности    |
| ------------------------------ | ---------------------------------- | -------------------- |
| $(u, v) \in E$ ?               | $O(deg(u))$                        | $O(1)$               |
| $E' = E \backslash \{(u, v)\}$ | $O(deg(u))$                        | $O(1)$               |
| Получить список соседей        | $O(1)$                             | $O(\vert V \vert)$   |
| Потребляемая память            | $O(\vert V \vert + \vert E \vert)$ | $O(\vert V \vert^2)$ |
### Обходы
#### Depth-First Search

***def*** *DFS* (depth first seach) – обход в глубину, т.е. обход графа, в котором вершины посещаются как только обнаружены.
Псевдокод:
```java
private static void dfs(ArrayList<Integer>[] graph, int v, int visited) {
	visited[v] = true;
	
	for (int u: gragh[v]) {
		if (!visited[u]) {
			dfs(graph, u, visited);
		}
	}
	
	// Вот здесь выход из вершины (см. топсорт)
}
```
Чёт в таком духе. Без рекурсии пишется со стеком.

#### Breadth-First Search

***def*** *BFS* (breadth-first search) – обход в ширину, т.е. обход графа, в котором сначала посещаются соседи начальной вершины, затем их соседи и т.д.

*Алгоритм:*
- Заведём очередь вершин в неё положим стартовую $s$
- Пока очередь не пустая:
  1. Извлечём вершину $v$ из начала очереди, пометим $v$ как посещённую.
  2. Добавим все смежные не посещённые вершины в очередь.

*Псевдокод:*
```kotlin
private static void bfs(ArrayList<Integer>[] graph, int s) {
	bool[] visited = new bool[];
	ArrayDeque<Integer> queue = new ArrayDeque<Integer>();
	
	queue.add(s)
	while (queue.peek() != null) {
		int v = queue.pop();
		visited[v] = true;
		
		for (int u: graph[v]) {
			if (!visited[u]) {
				queue.add(u);
			}
		}
	}
}
```

#### Topsort

Рассмотрим ориентированный граф, присвоим каждой вершине номер. 

***def*** Перестановка $\sigma$ называется *топологической сортировкой*, если $\forall (u, v)\in E \hookrightarrow \sigma(u) < \sigma(v)$

![](images/algo/topsort.png)

Топологическая сортировка существует только в ацикличном орграфе (т.к. отношение "<" ациклично).

*Алгоритм построения:*
1. Запустим DFS на всём графе. В момент выхода DFS из вершины будем добавлять её в конец массива.
2. Развернём полученный массив. Он содержит перестановку, являющуюся корректным топсортом:
	   В DFS, если вершина $u$ достигается из $v$, то $u$ будет обработана раньше $v$ (раньше выйдет из стека), поэтому сортировка вершин в порядке убывания времён выхода является топологической сортировкой.

_____
## 9. Задача поиска кратчайших путей в графе. Алгоритм Дейкстры. Алгоритм Форда–Беллмана.

***def*** *Взвешенным графом* будем называть тройку $G=(V, E, w)$, где $V$ и $E$ – множества вершин и рёбер соответственно, а $w: E \to K \subseteq \mathbb{R}$ – весовая функция.

***def*** Весом пути $p=v_1...v_k$ будем называть величину $w(p) = \sum_{i=1}^{k-1}w(v_i, v_{i+1})$

***def*** Кратчайшим путём от вершины $s$ до вершины $t$, назовём такой путь $p=sv_1...v_kt$, что его вес минимален среди всех возможных путей от $s$ до $t$. Длину такого пути буде обозначать $dist(s, t)$ и называть расстоянием.

#### Алгоритм Дейкстры

*Цель:* Найти расстояния (+ кратчайшие пути) от вершины $s$ до всех остальных, если $w:E \to \mathbb{R}^+$

*Алгоритм:*
- Пусть $S={s}$ – множество вершин, для которых расстояние от $s$ вычислено корректно на текущий момент времени, $d[v]$ – оценка сверху на $dist(s, v)$ (инициализировать как +INF, $d[s] = 0$).
- Пока $S \neq V$:
  1. $from = arg \underset{v \in V \backslash S}{min} d[v]$
  2. $S = S \cup {from}$, присвоим $dist(s, from) = d[from]$
  3. Для рёбер вида $(from, to)$ проведём релаксацию, т.е. $d[to]=min(dist(s, from) + w(from, to), d[to])$

*Корректность:*
***st*** На момент добавления $v$ в $S$ верно, что $dist(s, v) = d[v]$
$\square$ 
Индукция по размеру $S$:
- *База:* $S={s}$ – всё корректно
- *Переход:* Пусть $d[v] > dist(s, v)$. Пусть $u$ – вершина, т.ч. на ней посчитали $d[v]$. Так как из $u$ была релаксация, значит $u \in S$. По предположению индукции, $d[u] = dist(s, u)$ $\implies d[v] = dist(s, u) + w(u, v)$. Если данный путь не кратчайший, то есть другой устроенный одним из двух образов:
	$u \to v$ (одно ребро) – путь до $v$ состоит только из вершин из $S$. Но мы выбрали вершину $u$ таким образом, что она заканчивает путь из вершин из $S$, т.е. этот случай уже рассмотрен.
	
	$u \to V \backslash S \to v = ut \to v$ – путь начался в $S$, далее попал в $V \backslash S$ и далее пришёл в v. Пусть ребро $(u, t)$ такое, что $u \in S, t \notin S$. Если таких несколько, то выберем последнее на пути из них. Так как $u \in S$, то $d[t] = dist(s, t)$, при этом известно, что $d[t] \geq  d[v]$, т.к. иначе мы бы рассматривали $t$, а не $v$. Известно, что $w(t...v) \geq 0$, откуда: $$dist(s, v) = dist(s, t) + w(t...v) \geq dist(s, t) = d[t] \geq d[v] > dist(s, v)$$Противоречие завершает доказательство. 
$\blacksquare$

*Время:*
- Уменьшение оценки d для вершины: каждое ребро уменьшает оценку не более одного раза, значит таких операций $O(\vert E \vert)$.
- Получение вершины с минимальной оценкой d не из S: каждая вершина извлекается не более одного раза, значит таких операций $O(\vert V \vert)$.

| Контейнер вершин | Релаксация               | Извлечение               | Итого                                  |
| ---------------- | ------------------------ | ------------------------ | -------------------------------------- |
| Массив           | $O(1)$                   | $O(\vert V \vert)$       | $O(\vert V \vert ^2)$                  |
| Дерево           | $O(\log{\vert V \vert})$ | $O(\log{\vert V \vert})$ | $O(\vert E \vert \log{\vert V \vert})$ |
	(Пути можно восстановить, если куда-то писать, какая вершина вызвала релаксацию в данной, тогда parent[to] = from)
#### Алгоритм Форда-Беллмана

*Цель:* Найти расстояния от вершины $s$ до всех остальных, если $w:E \to \mathbb{R}$, в предположении, что нет циклов отрицательного веса.

*Алгоритм (дп):*
1. *Что хранит в себе состояние динамики?* Пусть $dp[v][k]$ равно минимальному весу пути из $s$ в $v$ ровно из $k$ рёбер.
2. *База:* $dp[s][0] = 0, \space dp[:][:] = +\inf$
3. *Переход:* $dp[v][k]=\underset{(u, v) \in E}{min}(dp[u][k-1] + w(u,v))$
4. *Какой порядок пересчёта?* Внешний цикл по $k$, внутри цикл по рёбрам
5. *Где лежит ответ на задачу?* $ans[v] = \underset{k}{min} dp[v][k]$

Алгоритм рассчитывает матрицу $dp$. По первому измерению – все вершины, т.е. $\vert V \vert$, по второму – длина пути, т.е. $\vert V \vert - 1$, откуда памяти $O(\vert V \vert ^2)$

Время работы вытекает из порядка пересчёта, т.е. $O(\vert V \vert \vert E \vert)$

***def*** *Циклом отрицательного веса* назовём цикл $v_1...v_nv_1$, у которого $\sum_{i=1}^n w(v_i, v_{(i+1)\%n})\lt0$. При поиске кратчайших путей можно ходить по нему бесконечно долго, получая путь сколь угодно малого веса.

Для поиска циклов отрицательного веса можно адаптировать алгоритм Форда-Беллмана: храним для каждой вершины предка, из которого она релаксировалась.

***st*** На $\vert V \vert$-ой итерации найдена вершина $v$, до которой расстояние уменьшилось по сравнению с $(\vert V \vert - 1)$-ой итерацией $\iff$ В графе есть цикл отрицательного веса, достижимый из $s$.

$\square$ 

$(\implies)$ Простой кратчайший путь не может быть длиннее $\vert V \vert -1$ рёбер, а если произошла релаксация, то существует **не** простой путь, имеющий вес строго меньший, а значит есть цикл отрицательного веса.

$(\impliedby )$ Рассмотрим цикл отрицательного веса $C = c_1...c_k$ т.к. $\vert C \vert < \vert V \vert$, на $\vert V \vert$-ой итерации найдётся вершина $c_i$ из $C$, которая будет рассмотрена ещё (второй или более) раз, при этом она будет рассмотрена по пути вдоль отрицательного цикла, а значит произойдёт релаксация.

$\blacksquare$

___
## 10. Задача построения минимального остовного дерева. Алгоритм Крускала. Алгоритм Прима.

***def*** *Остовом* графа $G = (V, E)$ будет называть граф $H = (V, E')$, где $E' \subseteq E$

***def*** *Остовным деревом* графа $G$ будем называть остов, образующий дерево.

***def*** *Минимальным остовным деревом* графа  $G = (V, E, w)$ будем называть такое остовное дерево $H = (V, E', w)$, что $\sum_{e \in E'} w(e)$ минимальна. Будем называть его *Minimum Spanning Tree (MST)*.

##### Лемма о безопасном ребре

***def*** $<S, T>$ – разрез, если $S \cup T = V, S \cap T = \varnothing$. Ребро $(u, v)$ пересекает разрез, если $u$ и $v$ в разных частях разреза.

***def*** Пусть $G' = (V, E')$ – подграф некоторого MST графа $G$. Ребро $(u, v) \in E$ безопасное, если при добавлении его в $G'$, $G'' = (V, E' \cup \{ (u, v) \})$ также является подграфом некоторого MST графа $G$.

***lemm*** Рассмотрим связный взвешенный граф $G = (V, E, w), w: E \to \mathbb{R}$. Пусть $G' = (V, E')$ – подграф некоторого MST графа $G$, $<S, T>$ – разрез $G$, т.ч. ни одно ребро из $E'$ не пересекает разрез, а $e = (u, v)$ – ребро минимального веса, пересекающее разрез $<S, T>$. Тогда ребро $e$ является безопасным.

$\square$

Достроим $E'$ до некоторого MST, который обозначим $T_{min}$. Если $e \in T_{min}$, то лемма доказана, поэтому предположим, что $e \notin T_{min}$. 

Рассмотрим путь в $T_{min}$ от вершины u до вершины v. Хотя бы одно ребро $e'$ на этом пути пересекает разрез (выберем любое). По условию, $w(e) \leq w(e')$. Заменим ребро $e'$ в $T_{min}$ на $e$. Полученное дерево также является MST $G$, поскольку все вершины $G$ по-прежнему связны и вес дерева не увеличился. $\implies$ $E' \cup \{e\}$ можно дополнить до миностова в графе $G$, т.е. ребро $e$ – безопасное.

$\blacksquare$

#### Алгоритм Прима

*Цель:* Найти MST графа $G = (V, E, w)$

*Алгоритм:*
Изначально $S = {s}$, где $s$ – произвольная вершина.
1. Рассмотрим разрез $<S, T>$. Найдём безопасное для него ребро $e=(u, v)$, где $u \in S$.
2. Добавим $e$ в миностов и $v$ в $S$.
3. Добавим в множество рёбер, пересекающих разрез, рёбра, выходящие из $v$ и идущие не в $S$.
4. Повторять пока $S \neq V$.

*Сложность:*
- Добавление рёбер в множество пересекающих разрез $\vert E \vert$ раз.
- Удаление ребра минимального веса через разрез $\vert V \vert - 1$ раз.

| Контейнер Рёбер | Добавление               | Извлечение               | Итого                                                  |
| --------------- | ------------------------ | ------------------------ | ------------------------------------------------------ |
| Массив          | $O(1)$                   | $O(\vert V \vert)$       | $O(\vert V \vert ^2)$                                  |
| Дерево Поиска   | $O(\log{\vert V \vert})$ | $O(\log{\vert V \vert})$ | $O(\vert E \vert + \vert V \vert \log{\vert V \vert})$ |
	Добавление в массиве можно реализовать так: изначально инициализировать вес равный +INF, а далее, при пересечении разреза, ставить реальный вес.

#### Алгоритм Крускала

*Цель:* Найти MST графа $G = (V, E, w)$

*Алгоритм:*
1. Отсортируем рёбра по весу.
2. Итерируясь по рёбрам, проверяем, приводит ли его добавление к циклу. Если нет – берём, иначе пропускаем.

	Второй шаг легко проверить, используя для хранения компонент связности DSU (Disjoint Set Union) – структуру данных с интерфейсом: unite(a, b) – объединить два множества, где находятся a и b, are_same(a, b) – узнать, лежат ли a и b в одном множестве. В реализации на массиве с весовой эвристикой и эвристикой сжатия путей время на запрос составляет $O(\alpha ( n))$, где $n$ – число вершин, $\alpha(x) = min\{ k \vert A(k, k) \geq x\}$ – обратная функция Аккермана. 
	- Сама функция Аккермана: $$A(m, n) = \begin{cases} n+1, \space m=0 \\ A(m-1, 1), \space n = 0 \\ A(m-1, A(m, n-1)), \space \text{else} \end{cases}$$
	- Пример: $A(4, 4) = 2^{2^{2^{2^{65536}}}} - 3$
	- В большинстве случаев $\alpha(n) \leq 4$, однако опускать её при анализе нельзя.

По итогу время работы первого шага – $O(\vert E \vert \log{\vert E \vert})$, второго – $O(\vert E \vert \alpha (\vert V \vert))$. Итого, время работы алгоритма $O(\vert E \vert \log{\vert E \vert})$.

___
## 11. Задача о максимальном потоке в графе. Теорема Форда–Фалкерсона. Алгоритм Эдмондса–Карпа.

[TODO]

___
## 12. Дерево отрезков. Ограничения на поддерживаемую операцию. Запросы модификации на отрезке.

[TODO]

___
## 13. Быстрое преобразование Фурье. Применение для умножения длинных чисел и многочленов.

[TODO]

___
## 14. Нахождение обратного элемента по модулю. Быстрое возведение в степень.

[TODO]

___
## 15. Задача поиска подстроки в строке. Алгоритм Рабина–Карпа. Алгоритм Кнута–Морриса–Пратта.

[TODO]

___
## 16. Бор. Алгоритм Ахо–Корасик.

[TODO]