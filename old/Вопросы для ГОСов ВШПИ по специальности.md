  
**Раздел 1\. Алгоритмы и структуры данных**

1. Сортировка слиянием (mergesort). Определение числа инверсий в перестановке за O(n log n).  
2. Быстрая сортировка (quicksort). Поиск k-й порядковой статистики за линейное в среднем время.  
3. Двоичная куча. Пирамидальная сортировка. Построение кучи за линейное время.  
4. Хеш-таблицы. Методы разрешения коллизий: метод цепочек, открытая адресация. Универсальное семейство хеш-функций.  
5. Амортизированная сложность. Динамический массив и оценка сложности его операций.  
6. Динамическое программирование: одномерное, двумерное.  
7. Самобалансирующиеся деревья поиска (рассказать любое на выбор). Реализация и оценка сложности операций вставки, удаления, поиска.  
8. Графы. Представление графов в памяти. Обход в ширину. Обход в глубину. Топологическая сортировка.  
9. Задача поиска кратчайших путей в графе. Алгоритм Дейкстры. Алгоритм Форда–Беллмана.  
10. Задача построения минимального остовного дерева. Алгоритм Крускала. Алгоритм Прима.  
11. Задача о максимальном потоке в графе. Теорема Форда–Фалкерсона. Алгоритм Эдмондса–Карпа.  
12. Дерево отрезков. Ограничения на поддерживаемую операцию. Запросы модификации на отрезке.  
13. Быстрое преобразование Фурье. Применение для умножения длинных чисел и многочленов.  
14. Нахождение обратного элемента по модулю. Быстрое возведение в степень.   
15. Задача поиска подстроки в строке. Алгоритм Рабина–Карпа. Алгоритм Кнута–Морриса–Пратта.  
16. Бор. Алгоритм Ахо–Корасик.

**Раздел 2\. Основные концепции языков программирования**  
**(По выбору студента, можно отвечать на вопросы, используя язык С++ или Java)**

**С++:**

1. Фундаментальные типы данных. Целочисленные типы, представление отрицательных чисел. Числа с плавающей точкой, их двоичное представление. Символьный и логический типы. Явные и неявные приведения типов. Перегрузка функций.  
2. Области памяти. Стек, куча, статическая память. Ошибка “stack overflow”. Способы ручного управления памятью.  
3. Указатели. Сходства и различия между указателями и массивами. Ссылки. Константы. Комбинация слова const с указателями и ссылками.  
4. Классы. Объекты. Поля, методы. Конструкторы. Ключевое слово this. Статические члены класса. Модификаторы доступа, инкапсуляция. Внутренние классы, локальные классы, их особенности и примеры.  
5. Наследование. Преобразования типов между родителем и наследником. Переопределение методов у наследника. Абстрактные классы. Виртуальные функции. Принцип подстановки Лисков.  
6. Исключения. Иерархия исключений.   
   Проблемы исключений в конструкторах и деструкторах. Ключевое слово noexcept.  
7. Шаблоны классов и функций. Специализации шаблонов. Разница между перегрузкой и специализацией для шаблонов функций. Зависимые имена в шаблонах. Простейшие type traits.  
8. Стандартные контейнеры: vector, list, deque, map, unordered\_map. Их основные методы и внутреннее устройство.  
9. Лямбда-функции. Элементы функционального программирования. Захват окружения. Обобщенные лямбда-функции.  
10. Move-семантика. Rvalue-ссылки и их отличия от обычных ссылок. Функции std::move и std::forward.  
11. Идиома RAII. Умные указатели. Основные методы и внутреннее устройство класса std::shared\_ptr.  
12. Правило одного определения (ODR). Линковка. Единицы трансляции. Ключевое слово extern. Динамические библиотеки.  
13. Основы многопоточности. Потоки (threads). Создание и завершение потоков. Проблема race condition. Мьютексы и их использование.  
14. Модель памяти. Проблема гонки данных и ее решение. Отношение happens-before. Класс std::atomic и разновидности memory order.  
15. Асинхронное программирование. Блокирующие и неблокирующие операции. Классы std::promise и std::future.   
    **Альтернативные варианты вопросов 12-15 из программы курса С++ набора 2022 года:**

12\. Итераторы. Категории итераторов. Принцип работы range-based for. Инвалидация итераторов в контейнерах. Output-итераторы. Const- и reverse-итераторы. Функции std::advance и std::distance.  
13\. Аллокаторы. Класс std::allocator и структура std::allocator\_traits. Использование аллокаторов в контейнерах. Placement new. Перегрузка операторов new и delete.  
14\. Идиома type erasure. Класс std::any и его внутреннее устройство. Класс std::function, его применение и внутреннее устройство.  
15\. Ограничения, ключевое слово requires. Виды ограничений. Концепты (concepts). Примеры реализации и использования концептов.

**Java:**

1. Фундаментальные типы данных. Целочисленные типы, представление отрицательных чисел. Числа с плавающей точкой, их двоичное представление. Символьный и логический типы. Явные и неявные приведения типов. Перегрузка функций.  
2. Классы. Объекты. Поля, методы. Конструкторы. Ключевое слово this. Статические члены класса. Модификаторы доступа, инкапсуляция. Внутренние классы, локальные классы, их особенности и примеры.  
3. Наследование. Преобразования типов между родителем и наследником. Переопределение методов у наследника. Абстрактные классы. Интерфейсы. Принцип подстановки Лисков.  
4. Исключения. Иерархия исключений. Проверяемые и непроверяемые исключения. Конструкция try with resources.  
5. Стандартные коллекции: ArrayList, LinkedList, HashMap, TreeMap, LinkedHashMap. Их основные методы и внутреннее устройство.  
6. Лямбда-функции.Элементы функционального программирования. Захват окружения. Ссылки на методы.  
7. Optional. Stream API. Промежуточные и терминальные операции. Коллекторы, комбинации коллекторов.  
8. Аннотации. Объявление и применение аннотаций. Мета-аннотации @Target, @Retention. Параметры аннотаций.  
9. Основы многопоточности. Потоки (threads). Создание и завершение потоков. Проблема race condition. Мьютексы и их использование.  
10. Spring Framework. Чем отличается управление объектами через \`new\` от управления через Inversion of Control. Какие способы внедрения зависимостей поддерживаются. Что такое Spring Bean и какие аннотации используются для создания бинов. Скоупы бинов.  
11. Spring MVC. Отличие \`@Controller\` от \`@RestController\`. Маппинг HTTP-запросов (\`@GetMapping\`, \`@PostMapping\`и т.д). Обработка исключений с помощью \`@ControllerAdvice\`. Интерcепторы. Валидация объектов (\`@NotBlank\`, \`@Email\` и т.д).  
12. OpenAPI. Использование OpenAPI в документирование REST API. Инструменты для генерации документации OpenAPI в Spring.  
13. Hibernate. Как Hibernate связан с JPA. Как работают \`@OneToMany\`, \`@ManyToOne\`, \`@ManyToMany\`? В чем разница между \`EAGER\` и \`LAZY\` загрузкой? Жизненный цикл сущности в Hibernate. Транзакции в Spring ('@Transactional'), параметры \`isolation\` и\`propagation\`.  
14. Spring Security. Настройка аутентификации через базу данных. Реализация JWT-аутентификации в Spring Security.  
15. Синхронное и асинхронное взаимодействие в распределенной среде, их преимущества и недостатки. Реализации инструментов (HTTP, брокеры сообщений и т.д).  
    

**Раздел 3\. Базы данных**

1. Реляционная модель данных: Основные понятия: отношение, атрибут, кортеж, домен, схема, степень. Ключи: потенциальный, первичный, внешний.  
2. Основы SQL. SELECT: cинтаксис, порядок выполнения. Фильтрация, сортировка, агрегация. Соединений (JOIN), типы соединений. Теоретико-множественные операции.  
3. Оконные функции в SQL: cинтаксис OVER(), PARTITION BY, ORDER BY. агрегатные функции в оконном контексте. Ранжирующие функции. Смещения. Фреймы.  
4. CTE (Common Table Expressions): Синтаксис WITH, рекурсивные CTE.  
5. Проектирование баз данных. Обеспечение целостности, устранение аномалий, минимизация избыточности. Этапы проектирования: Концептуальное (ER-диаграммы, связи), логическое (нормализация), физическое.  
6. Нормализация в базах данных. Нормальные формы: определения 1НФ, 2НФ, 3НФ, НФ Бойса-Кодда.  
7. Транзакции в SQL. Команды для работы с транзакциями. Свойства ACID: Атомарность, Согласованность, Изолированность, Долговечность.  
8. Уровни изоляции транзакций. Проблемы изолированности: "Грязное чтение", "Неповторяющееся чтение", "Фантомы".  
9. План запроса: Операторы EXPLAIN и ANALYZE. Чтение и анализ плана (Seq Scan, Index Scan, Join методы).  
10. Индексы: Назначение, условия использования. Типы: B-Tree, Hash, GiST, GIN, BRIN (номинально)  
11. Методы доступа к данным: Seq Scan, Index Scan, Index Only Scan, Bitmap Scan.  
12. Буферный кэш и WAL (Write-Ahead Log): Принципы работы, роль в обеспечении ACID.  
13. Реализация изоляций транзакций в PostgreSQL. Версии строк. Снимки данных. Отмена транзакций. Горизонт транзакции и горизонт базы данных. Ручная и автоматическая очистка (VACUUM).  
    

**Раздел 4\. Компьютерные сети**

1. Основы организации компьютерных сетей. Эталонные модели сетей. Модель взаимодействия открытых систем ISO OSI. Модель TCP/IP. Стек протоколов TCP/IP.  
2. Канальный уровень. MAC-адреса. Технология Ethernet, работа коммутаторов. Протокол ARP.   
3. Канальный уровень. Технология Wi-Fi. Метод доступа к разделяемой среде CSMA/CA.  
4. Сетевой уровень. IP-адреса. Протокол IP. Версии IP: IPv4 и IPv6.  
5. Сетевой уровень: маршрутизация. Задача маршрутизации. Маршрутизатор. Таблица маршрутизации.  
6. Транспортный уровень. Порты. Протокол UDP. Сокеты.  
7. Транспортный уровень. Протокол TCP. Обеспечение надежной передачи данных. Подтверждения. Скользящее окно. Соединение TCP. Управление потоком и перегрузкой.  
8. Транспортный уровень. Протокол QUIC.   
9. Прикладной уровень. Протокол HTTP. Версии протокола HTTP: 1, 2, 3\.  
10. Прикладной уровень. Система доменных имен DNS. Протокол DNS.   
11. Защищенные сетевые протоколы: TLS, HTTPS.  
    

**Раздел 5\. Машинное обучение**

1. Базовые понятия: объекты, признаки, целевые значения (таргет), обучающая, тестовая и валидационная выборка. Стандартные задачи машинного обучения: классификация, регрессия и кластеризация. Обучение с учителем и без учителя. Метрики качества и функции потерь. Недообучение и переобучение, кривые обучения. Кросс-валидация и ее виды. Параметры и гипер-параметры алгоритмов.  
2. Простые методы решения стандартных задач машинного обучения. Метод k ближайших соседей и центроидный классификатор, наивный байесовский классификатор, метод K средних (KMeans).  
3. Линейная классификация и регрессия. Функции потерь и метод стохастического градиентного спуска. Регуляризация в линейных моделях. Оптимизационная задача в логистической регрессии и методе опорных векторов. Аналитическое решение в задаче линейной регрессии и гребневой регрессии. Оптимизационная задача в LASSO. Различия между l1 и l2 регуляризаторами.  
4. Метод опорных векторов. Постановка условной оптимиза ционной задачи (в случае линейно неразделимой выборки) из принципа максимизации разделяющей полосы. Сведение условной задачи оптимизации к безусловной. Опорные векторы и их связь с двойственной задачей. Kernel trick.  
5. Решающие деревья и ансамбли. Критерии выбора разбиений в узлах дерева. Бэггинг и бустинг: идея и различия. Случайный лес. Градиентный бустинг над деревьями.  
6. Метрики оффлайн качества в задачах обучения с учителем: accuracy, precision, recall, F1, ROC-AUC, log loss, MSE, MAE, MAPE, SMAPE. Онлайн оценка качества: основная идея A/B тестирования и оценки стат.значимости.  
7. Обучение без учителя. Задача кластеризации. KMeans, иерархическая кластеризация, DBSCAN. Задача понижения размерности. Метод главных компонент (идея и интерпретация, без вывода). Manifold learning (основная идея и примеры алгоритмов)  
8. Нейронные сети. Принцип работы и матричная запись. Примеры нелинейностей. Граф вычислений. Метод обратного распространения ошибки. Связь с методом стохастического градиентного спуска.

